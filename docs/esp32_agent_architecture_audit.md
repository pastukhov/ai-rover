# ESP32 AI Agent — Architecture Audit Request

## Контекст

Этот документ описывает эталонную архитектуру AI агента для ресурсно-ограниченных устройств (ESP32).
Задача Claude Code — провести аудит текущей кодовой базы на соответствие этим принципам и выявить отклонения.

---

## Эталонная архитектура

### Распределение по ядрам (Dual-Core ESP32)

| Ядро | Роль | Что НЕ должно здесь быть |
|------|------|--------------------------|
| Core 0 (RT) | FreeRTOS задачи, моторы, сенсоры, PWM, I2C/UART | Блокирующие HTTP вызовы, динамическая аллокация в hot path |
| Core 1 (Agent) | Сбор состояния, HTTP клиент, парсинг LLM ответа, FSM переходы | Прямое управление периферией, блокировка RT задач |

### Межядерное взаимодействие

- Только через FreeRTOS примитивы: `QueueHandle_t`, `RingbufHandle_t`, `EventGroupHandle_t`
- Никаких глобальных переменных без `volatile` и мьютексов
- Таймаут на любой `xQueueSend` / `xQueueReceive` — агент не должен блокироваться навсегда

### Локальный FSM (Finite State Machine)

Устройство должно иметь явный конечный автомат с ограниченным набором состояний:

```
IDLE → COLLECTING_STATE → SENDING_TO_LLM → AWAITING_RESPONSE → EXECUTING_ACTION → IDLE
                                                    ↓ (timeout/error)
                                               OFFLINE_FALLBACK
```

- Состояния и переходы — явные, не имплицитные
- `OFFLINE_FALLBACK` обязателен: устройство работает без LLM при потере связи
- Переходы между состояниями логируются (хотя бы в Serial)

### Remote LLM взаимодействие

- HTTP запрос формируется из минимального снапшота состояния (не весь лог, не сырые данные сенсоров)
- Запрос имеет явный `timeout` (рекомендуется 5–15 сек)
- Ответ LLM — это команда или набор команд, не свободный текст для интерпретации
- Парсинг ответа — детерминированный (JSON с фиксированной схемой, не regex по тексту)

### Tool / Action Layer

- Каждое действие — отдельная функция с явными входными параметрами и возвратом статуса
- Read-only действия (чтение сенсора) отделены от side-effect действий (включить мотор)
- Критичные действия (высокий ток, нагрев, движение) имеют guard conditions перед исполнением
- Нет прямых вызовов периферии из логики агента — только через абстракцию

### Memory Management

- Нет динамической аллокации (`malloc`/`new`) в задачах реального времени
- Буферы под HTTP и JSON — статические или из pre-allocated пула
- Размер контекста, отправляемого в LLM, ограничен константой (не растёт бесконтрольно)
- PSRAM (если есть) используется для буферов, не для критичных структур управления

### Safety Layer

- Watchdog таймер настроен и не отключён
- Есть аппаратные или программные лимиты на опасные действия (макс. скорость, макс. ток)
- Агент не может выполнить действие, пока предыдущее не завершено (нет очереди команд без bounds)
- При получении невалидного ответа от LLM — агент переходит в безопасное состояние, не игнорирует

---

## Задание для аудита

Проверь кодовую базу по следующим пунктам и для каждого дай оценку: ✅ OK / ⚠️ Частично / ❌ Проблема.

### Checklist

#### Разделение ядер
- [ ] RT-задачи явно привязаны к Core 0 (`xTaskCreatePinnedToCore`)
- [ ] Agent-логика явно привязана к Core 1
- [ ] Нет блокирующих вызовов в RT-задачах (HTTP, vTaskDelay > 10ms, Serial.print в hot path)

#### Межядерное взаимодействие
- [ ] Все shared данные защищены мьютексом или передаются через очередь
- [ ] Все очереди имеют таймаут (не `portMAX_DELAY` без причины)
- [ ] Нет глобальных переменных, доступных из обоих ядер без синхронизации

#### FSM
- [ ] Состояния явно определены (enum или аналог)
- [ ] Все переходы явные и полные (нет "провалов" в undefined поведение)
- [ ] Offline fallback состояние реализовано
- [ ] Состояния логируются при переходе

#### LLM взаимодействие
- [ ] HTTP запрос имеет таймаут
- [ ] Размер payload ограничен константой
- [ ] Ответ парсится через JSON схему, не через строковый поиск
- [ ] Ошибки сети обрабатываются явно (не просто `if (!response) return`)

#### Tool Layer
- [ ] Действия инкапсулированы в функции, не inline в логике агента
- [ ] Read-only и side-effect действия разделены
- [ ] Критичные действия имеют проверки перед исполнением
- [ ] Возвращаемый статус действий проверяется

#### Memory
- [ ] Нет `malloc` в RT-задачах
- [ ] HTTP / JSON буферы статические или pooled
- [ ] Максимальный размер контекста LLM задан константой

#### Safety
- [ ] Watchdog включён и не перекрыт агентом
- [ ] Есть лимиты на опасные действия
- [ ] Невалидный LLM ответ → безопасное состояние
- [ ] Нет бесконечных циклов без выхода по таймауту

---

## Ожидаемый формат вывода

По каждому пункту чеклиста:
1. Оценка: ✅ / ⚠️ / ❌
2. Где в коде проблема (файл, функция, строка)
3. Конкретная рекомендация по исправлению

В конце — сводная таблица с приоритетами исправлений (Critical / High / Medium / Low).
